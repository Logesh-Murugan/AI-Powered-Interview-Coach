"""
Question Model

This model stores interview questions generated by AI providers.
Questions are cached and reused to minimize API calls and costs.

Requirements: 12.1-12.15, 13.1-13.10
"""
from sqlalchemy import Column, String, Integer, Text, ARRAY, JSON, DateTime, Index
from sqlalchemy.dialects.postgresql import JSONB
from datetime import datetime

from app.models.base import BaseModel


class Question(BaseModel):
    """Interview question model"""
    __tablename__ = 'questions'
    
    # Question content
    question_text = Column(Text, nullable=False)
    category = Column(String(50), nullable=False)  # Technical, Behavioral, Domain_Specific, System_Design, Coding
    difficulty = Column(String(20), nullable=False)  # Easy, Medium, Hard, Expert
    role = Column(String(100), nullable=False)  # Target role for this question
    
    # Answer guidance
    expected_answer_points = Column(JSONB, nullable=False)  # Array of key points expected in answer
    time_limit_seconds = Column(Integer, nullable=False, default=300)  # Time limit for answering
    
    # Metadata
    provider_name = Column(String(50))  # AI provider that generated this question
    generation_metadata = Column(JSONB)  # Additional metadata from generation
    usage_count = Column(Integer, default=0)  # How many times this question has been used
    
    # Indexes for efficient querying
    __table_args__ = (
        Index('idx_questions_role_difficulty', 'role', 'difficulty'),
        Index('idx_questions_category', 'category'),
        Index('idx_questions_role_difficulty_category', 'role', 'difficulty', 'category'),
    )
    
    def __repr__(self):
        return f"<Question(id={self.id}, role='{self.role}', difficulty='{self.difficulty}', category='{self.category}')>"
    
    def to_dict(self):
        """Convert question to dictionary"""
        return {
            'id': self.id,
            'question_text': self.question_text,
            'category': self.category,
            'difficulty': self.difficulty,
            'role': self.role,
            'expected_answer_points': self.expected_answer_points,
            'time_limit_seconds': self.time_limit_seconds,
            'usage_count': self.usage_count,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }
